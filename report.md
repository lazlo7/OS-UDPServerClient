# 4 - 5 балла

## Информация об исполнителе

см. `README.md`

## Условие задачи

см. `README.md`  

`$ make mark4` для сборки.  

## Модель решаемой задачи

Введем нейтральные обозначения для модели:
- `Stealer` - *Вор* - Иванов;
- `Loader` - *Грузчик* - Петров;
- `Observer` - *Наблюдатель* - Нечепорук.
Данные обозначения используются и в исходном коде программы.

Под сворованным *предметом* в данной модели подразумевается его цена. 

`Stealer`, `Loader`, `Observer` - три процесса, занимающихся выполнением своей части работы (работа зацикливается после '...'):
- `Stealer`: **Ворует предметы из склада**, ждет `Loader` в точке передачи, передает `Loader` предмет, ...
- `Loader`: Ждет, когда `Stealer` принесет новый предмет, принимает предмет от `Stealer`, **погружает предмет в грузовик**, оповещает `Observer` о новом предмете, ... 
- `Observer`: Стоит на шухере, **при получении оповещения от `Loader`, считает количество предметов в грузовике, стоимость нового предмета и общую стоимость сворованных предметов**, ...

**Жирным шрифтом** выделены действия процессов, которые занимают случайное время (см. условие задачи).   

Синхронизация и коммуникация процессов происходит с помощью `UDP` сервера.  
Так как число клиентов фиксировано условием задачи и клиенты зависят друг от друга, то было решено организовать обработку клиентов последовательно в цикле. Такой подход значительно облегчает архитектуру сервера, позволяя не прибегать к многопоточности и т. п. Более того, клиенты устроены таким образом, что при завершении обработки одного, завершается обработка всех остальных. 

Главный цикл сервера:
1. Принимает предмет от `Stealer`а;
2. Посылает предмет `Loader`у;
3. Принимает подтверждение об успешной передачи от `Loader`а (после этого `Loader` несет предмет в грузовик);
4. Посылает подтверждение об успешной передачи `Stealer`у (после этого `Stealer` идет опять воровать из склада);
5. Принимает предмет от `Loader`а (`Loader` уже загрузил предмет в грузовик);
6. Посылает предмет `Observer`у.

Главный цикл работает до тех пор, пока не встретится предмет с отрицательной стоимостью. Это "сигнал" от `Stealer`а, что больше нечего воровать, и пора завершать работу. В свою очередь для `Loader`а это означает, что больше нечего грузить в грузовик, а для `Observer`а, что больше нечего считать. Таким образом, обработка всех клиентов может завершится сразу же после "сигнала" от `Stealer`а. 

Стоит заметить, что `Stealer` и `Loader` зависят друг от друга и не выполняют свою работу, пока не получат оповещения о взаимной готовности. В свою очередь `Observer` реализован таким образом, что он выполняет работу независимо от `Stealer` и `Loader` (`Loader` всего лишь через сервер пересылает новые предметы `Observer`у, но никак с ним не синхронизируется). Сервер просто отправляет новые предметы `Observer`у, не дожидаясь его ответа. Это позволяет предметам временно сохраняться в системном буфере и последовательно обрабатываться `Observer`ом.  

Считывание новой информации сервером (через `recv`, пункты: 1, 3, 5) реализует синхронизацию процессов, так как `recv` блокируется, пока буфер сокета пустой. Пункты 3, 4 позволяют реализовать важное условие задачи о передачи предмета "из рук в руки". То есть, клиенты не начинают выполнять свою работу пока не удостоверяться в передачи предмета. 

## Запуск программ
Запускайте программы в порядке `server` -> `client` -> `client` -> `client`.  
Роли клиентам присваиваются автоматически.  
Перед началом "воровства", `Stealer` попросит ввести число предметов на складе. Введите неположительное целое число для случайной генерации предметов. При вводе положительного числа, `Stealer` будет запрашивать стоимость каждого предмета (положительное целое число).  

### Запуск программ: Сервер
Для запуска сервера используйте

    $ ./server <server_port> [<server_ip>]

где:
- `<server_port>`: порт сервера (обязательный аргумент);
- `[<server_ip>]`: адрес сервера (необязательный аргумент, по умолчанию равен `127.0.0.1`). 

### Запуск программ: Клиент
Для запуска клиента используйте

    $ ./client <server_port> [<server_ip>]

где:
- `<server_port>`: порт сервера (обязательный аргумент);
- `[<server_ip>]`: адрес сервера (необязательный аргумент, по умолчанию равен `127.0.0.1`). 

## Завершение программ
Программы завершаются после выполнения своей части работы. Клиенты и сервер могут предварительно завершаться по приему сигнала `SIGINT` (*ctrl+c*). Программы также завершаются при неожиданной потери соединения с сокетом (`SIGPIPE`). Во всех случаях предусмотрено освобождение ресурсов.  
